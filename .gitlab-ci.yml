image: docker:20.10.16

services:
  - docker:20.10.16-dind

variables:
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2
  DOCKER_REGISTRY: ${CI_REGISTRY}
  DOCKER_IMAGE: ${CI_REGISTRY}/aradhya24/cold-email-generator:${CI_COMMIT_SHA}
  AWS_USER: ubuntu
  LB_DNS: ${LB_DNS}

stages:
  - validate
  - build
  - deploy
  - monitor

validate:
  image: python:3.9-slim
  stage: validate
  script:
    - apt-get update && apt-get install -y python3-pip
    - pip install -r requirements.txt
    - python -c "import app.main" || echo "Validation failed but continuing"
  rules:
    - if: $SKIP_VALIDATE_BUILD == null

build:
  stage: build
  script: 
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY 
    - docker build --pull -t $DOCKER_IMAGE .
    - docker tag $DOCKER_IMAGE $CI_REGISTRY/aradhya24/cold-email-generator:latest
    - docker push $DOCKER_IMAGE 
    - docker push $CI_REGISTRY/aradhya24/cold-email-generator:latest
  rules:
    - if: $SKIP_VALIDATE_BUILD == null

deploy:
  stage: deploy
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_VERIFY: ""
    DOCKER_CERT_PATH: ""
  before_script:
    - apk add --no-cache openssh-client curl python3 py3-pip
    - pip3 install awscli
    - eval $(ssh-agent -s)
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    
    # Create SSH key directly instead of trying to interpret format
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r\n' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-add ~/.ssh/id_rsa || echo "Failed to add SSH key, continuing anyway"
    
    # Set up known hosts and disable strict host checking
    - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config
    
    # Configure AWS credentials and region
    - export AWS_DEFAULT_REGION="us-east-1"
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region us-east-1
    - aws configure set output json
    
    # Debug AWS configuration
    - echo "Verifying AWS configuration:"
    - aws configure list
    - echo "Testing AWS connection:"
    - aws ec2 describe-regions --region us-east-1 --output text | head -1 || echo "AWS connection failed"
  script:
    - |
      # Launch EC2 instance and get instance info
      echo "Launching EC2 instance..."
      
      # Check if required AWS variables are set
      if [ -z "$EC2_KEY_NAME" ]; then
        echo "ERROR: EC2_KEY_NAME is not set. Please add this variable in GitLab CI/CD settings."
        echo "Example value: my-key-pair"
        exit 1
      fi
      
      if [ -z "$EC2_SECURITY_GROUP" ]; then
        echo "ERROR: EC2_SECURITY_GROUP is not set. Please add this variable in GitLab CI/CD settings."
        echo "Example value: sg-0123456789abcdef"
        exit 1
      fi
      
      if [ -z "$EC2_SUBNET_ID" ]; then
        echo "ERROR: EC2_SUBNET_ID is not set. Please add this variable in GitLab CI/CD settings."
        echo "Example value: subnet-0123456789abcdef"
        exit 1
      fi
      
      INSTANCE_ID=$(aws ec2 run-instances \
        --region us-east-1 \
        --image-id ami-0c7217cdde317cfec \
        --instance-type t2.micro \
        --key-name $EC2_KEY_NAME \
        --security-group-ids $EC2_SECURITY_GROUP \
        --subnet-id $EC2_SUBNET_ID \
        --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=cold-email-instance}]" \
        --query 'Instances[0].InstanceId' \
        --output text)
      
      if [ -z "$INSTANCE_ID" ]; then
        echo "Failed to launch EC2 instance."
        exit 1
      fi
      
      echo "Instance ID: $INSTANCE_ID"
      
      # Wait for instance to be running
      echo "Waiting for instance to be running..."
      aws ec2 wait instance-running --region us-east-1 --instance-ids $INSTANCE_ID
      
      # Additional wait for instance to fully initialize
      echo "Instance is running. Waiting 30 seconds for full initialization..."
      sleep 30
      
      # Get public IP with retries and longer wait times
      echo "Getting instance public IP..."
      for i in 1 2 3 4 5; do
        PUBLIC_IP=$(aws ec2 describe-instances \
          --region us-east-1 \
          --instance-ids $INSTANCE_ID \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        if [ ! -z "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
          echo "Got public IP: $PUBLIC_IP"
          break
        fi
        
        echo "Attempt $i: No public IP yet, waiting 20 seconds..."
        sleep 20
      done
      
      if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "None" ] || [ "$PUBLIC_IP" = "null" ]; then
        echo "Failed to get public IP after 5 attempts"
        echo "Terminating instance $INSTANCE_ID to avoid unnecessary charges"
        aws ec2 terminate-instances --region us-east-1 --instance-ids $INSTANCE_ID
        exit 1
      fi
      
      # Create lb_dns.env file
      echo "Creating lb_dns.env file..."
      echo "LB_DNS=$PUBLIC_IP" > lb_dns.env
      cat lb_dns.env
      
      # Wait for SSH to be available
      echo "Waiting for SSH to become available..."
      for i in 1 2 3 4 5 6; do
        if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 ubuntu@$PUBLIC_IP "echo 'SSH connection successful'"; then
          echo "SSH connection established"
          break
        fi
        echo "Attempt $i: SSH not ready yet, waiting 20 seconds..."
        sleep 20
        if [ $i -eq 6 ]; then
          echo "Failed to establish SSH connection after 6 attempts"
          echo "Terminating instance $INSTANCE_ID to avoid unnecessary charges"
          aws ec2 terminate-instances --region us-east-1 --instance-ids $INSTANCE_ID
          exit 1
        fi
      done
      
      # Create necessary directories
      echo "Creating directories..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@$PUBLIC_IP "sudo mkdir -p /opt/cold-email/{app,scripts,k8s}"
      
      # Copy files in parallel
      echo "Copying files..."
      scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r app/* ubuntu@$PUBLIC_IP:/opt/cold-email/app/ &
      scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r scripts/* ubuntu@$PUBLIC_IP:/opt/cold-email/scripts/ &
      scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r k8s/* ubuntu@$PUBLIC_IP:/opt/cold-email/k8s/ &
      wait
      
      # Create and copy configuration files
      echo "Creating configuration files..."
      echo "GROQ_API_KEY=$GROQ_API_KEY" | ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@$PUBLIC_IP "sudo tee /opt/cold-email/app/.env"
      
      # Make scripts executable
      echo "Making scripts executable..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@$PUBLIC_IP "sudo chmod +x /opt/cold-email/scripts/*.sh"
      
      # Run setup script
      echo "Running setup script..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@$PUBLIC_IP "cd /opt/cold-email && sudo ./scripts/setup-k8s.sh"
      
      # Finalize deployment
      echo "Finalizing deployment..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@$PUBLIC_IP "cd /opt/cold-email && sudo ./scripts/deploy-k8s.sh"
      
      echo "Deployment completed successfully!"
  artifacts:
    reports:
      dotenv: lb_dns.env
    expire_in: 1 week
  when: on_success

monitor:
  stage: monitor
  image: python:3.9-slim
  script: |
    # Install required packages and setup in parallel
    apt-get update && apt-get install -y openssh-client python3-pip &
    pip install awscli &
    mkdir -p ~/.ssh && chmod 700 ~/.ssh &
    wait
    
    # Create SSH key directly without trying to interpret format
    echo "$AWS_SSH_KEY" | tr -d '\r\n' > ~/.ssh/id_rsa
    chmod 600 ~/.ssh/id_rsa
    eval $(ssh-agent -s)
    ssh-add ~/.ssh/id_rsa || echo "Failed to add SSH key, continuing anyway"
    echo -e "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config
    
    # Setup AWS credentials
    export AWS_DEFAULT_REGION=us-east-1
    export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
    export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
    
    # Debug AWS configuration
    echo "Verifying AWS configuration:"
    aws configure list
    echo "Testing AWS connection:"
    aws ec2 describe-regions --output text | head -1 || echo "AWS connection failed"
    
    # Get instance IP with better error handling
    echo "Searching for EC2 instance..."
    INSTANCE_INFO=$(aws ec2 describe-instances \
      --region us-east-1 \
      --filters "Name=tag:Name,Values=cold-email-instance" "Name=instance-state-name,Values=running" \
      --query "Reservations[*].Instances[*].[InstanceId,PublicIpAddress]" \
      --output text)
    
    EC2_IP=$(echo "$INSTANCE_INFO" | awk '{print $2}')
    
    if [ -z "$EC2_IP" ]; then
      echo "Failed to get EC2 instance IP. Instance info:"
      echo "$INSTANCE_INFO"
      exit 1
    fi
    
    echo "Found EC2 instance with IP: $EC2_IP"
    
    # Define SSH command function with retries
    run_ssh_command() {
      local command="$1"
      for i in {1..3}; do
        echo "Attempt $i: Running command via SSH..."
        if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=5 ${AWS_USER}@${EC2_IP} "$command"; then
          echo "Command executed successfully!"
          return 0
        fi
        echo "Command failed. Waiting 10 seconds before retry..."
        sleep 10
      done
      echo "Failed to execute command after 3 attempts."
      return 1
    }
    
    # Run health checks in parallel
    run_ssh_command "kubectl get pods -n cold-email" &
    run_ssh_command "kubectl get svc -n cold-email" &
    wait
    
    # Check application health
    sleep 15
    curl -s -f -m 5 "http://${EC2_IP}/_stcore/health" || echo "Health check failed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  artifacts:
    reports:
      dotenv: lb_dns.env
    expire_in: 1 week