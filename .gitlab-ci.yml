image: docker:20.10.16

services:
  - docker:20.10.16-dind

variables:
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2
  DOCKER_REGISTRY: ${CI_REGISTRY}
  DOCKER_IMAGE: ${CI_REGISTRY}/aradhya24/cold-email-generator:${CI_COMMIT_SHA}
  AWS_USER: ubuntu
  LB_DNS: ${LB_DNS}

stages:
  - validate
  - build
  - deploy
  - monitor

validate:
  image: python:3.9-slim
  stage: validate
  script:
    - apt-get update && apt-get install -y python3-pip
    - pip install -r requirements.txt
    - python -c "import app.main" || echo "Validation failed but continuing"
  rules:
    - if: $SKIP_VALIDATE_BUILD == null

build:
  stage: build
  script: 
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY 
    - docker build --pull -t $DOCKER_IMAGE .
    - docker tag $DOCKER_IMAGE $CI_REGISTRY/aradhya24/cold-email-generator:latest
    - docker push $DOCKER_IMAGE 
    - docker push $CI_REGISTRY/aradhya24/cold-email-generator:latest
  rules:
    - if: $SKIP_VALIDATE_BUILD == null

deploy:
  stage: deploy
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_VERIFY: ""
    DOCKER_CERT_PATH: ""
  before_script:
    # Install required packages
    - apk add --no-cache openssh-client curl python3 py3-pip git
    
    # Clone the repository to ensure we have all files
    - git config --global user.email "gitlab-ci@example.com"
    - git config --global user.name "GitLab CI"
    - git clone $CI_REPOSITORY_URL ./ || echo "Repository already exists"
    
    # Install AWS CLI
    - pip3 install awscli
    
    # Setup SSH
    - eval $(ssh-agent -s)
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    
    # Generate a new SSH key for this pipeline run
    - echo "Generating new SSH key..."
    - ssh-keygen -t rsa -b 2048 -f ~/.ssh/ec2_key -N ""
    - chmod 600 ~/.ssh/ec2_key
    - ssh-add ~/.ssh/ec2_key
    - cat ~/.ssh/ec2_key.pub > ec2_key.pub
    
    # Set up known hosts and disable strict host checking
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config
    
    # Configure AWS credentials and region
    - export AWS_DEFAULT_REGION="us-east-1"
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region us-east-1
    - aws configure set output json
    
    # Debug AWS configuration
    - echo "Verifying AWS configuration:"
    - aws configure list
    - echo "Testing AWS connection:"
    - aws ec2 describe-regions --region us-east-1 --output text | head -1 || echo "AWS connection failed"
  script:
    - |
      # Launch EC2 instance with explicit network interface to ensure public IP
      echo "Launching EC2 instance..."
      
      # Check if required AWS variables are set
      if [ -z "$EC2_SECURITY_GROUP" ]; then
        echo "ERROR: EC2_SECURITY_GROUP is not set. Please add this variable in GitLab CI/CD settings."
        echo "Example value: sg-0123456789abcdef"
        exit 1
      fi
      
      if [ -z "$EC2_SUBNET_ID" ]; then
        echo "ERROR: EC2_SUBNET_ID is not set. Please add this variable in GitLab CI/CD settings."
        echo "Example value: subnet-0123456789abcdef"
        exit 1
      fi
      
      # Launch instance with a simple user data script
      echo "#!/bin/bash" > userdata.sh
      echo "mkdir -p /home/ubuntu/.ssh" >> userdata.sh
      cat ec2_key.pub > pubkey.txt
      echo "cat > /home/ubuntu/.ssh/authorized_keys << 'EOT'" >> userdata.sh
      cat pubkey.txt >> userdata.sh
      echo "EOT" >> userdata.sh
      echo "chmod 700 /home/ubuntu/.ssh" >> userdata.sh
      echo "chmod 600 /home/ubuntu/.ssh/authorized_keys" >> userdata.sh
      echo "chown -R ubuntu:ubuntu /home/ubuntu/.ssh" >> userdata.sh
      
      echo "User data script contents:"
      cat userdata.sh
      
      INSTANCE_ID=$(aws ec2 run-instances \
        --region us-east-1 \
        --image-id ami-0c7217cdde317cfec \
        --instance-type t2.micro \
        --network-interfaces "AssociatePublicIpAddress=true,DeviceIndex=0,Groups=$EC2_SECURITY_GROUP,SubnetId=$EC2_SUBNET_ID" \
        --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=cold-email-instance}]" \
        --user-data file://userdata.sh \
        --query 'Instances[0].InstanceId' \
        --output text)
      
      if [ -z "$INSTANCE_ID" ]; then
        echo "Failed to launch EC2 instance."
        exit 1
      fi
      
      echo "Instance ID: $INSTANCE_ID"
      
      # Wait for instance to be running
      echo "Waiting for instance to be running..."
      aws ec2 wait instance-running --region us-east-1 --instance-ids $INSTANCE_ID
      
      # Additional wait for instance to fully initialize
      echo "Instance is running. Waiting 30 seconds for full initialization..."
      sleep 30
      
      # Get public IP with retries and longer wait times
      echo "Getting instance public IP..."
      for i in 1 2 3 4 5; do
        PUBLIC_IP=$(aws ec2 describe-instances \
          --region us-east-1 \
          --instance-ids $INSTANCE_ID \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        if [ ! -z "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
          echo "Got public IP: $PUBLIC_IP"
          break
        fi
        
        echo "Attempt $i: No public IP yet, waiting 20 seconds..."
        sleep 20
      done
      
      if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "None" ] || [ "$PUBLIC_IP" = "null" ]; then
        echo "Failed to get public IP after 5 attempts"
        echo "Terminating instance $INSTANCE_ID to avoid unnecessary charges"
        aws ec2 terminate-instances --region us-east-1 --instance-ids $INSTANCE_ID
        exit 1
      fi
      
      # Create lb_dns.env file
      echo "Creating lb_dns.env file..."
      echo "LB_DNS=$PUBLIC_IP" > lb_dns.env
      cat lb_dns.env
      
      # Wait for SSH to be available
      echo "Waiting for SSH to become available..."
      for i in 1 2 3 4 5 6; do
        if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i ~/.ssh/ec2_key ubuntu@$PUBLIC_IP "echo 'SSH connection successful'"; then
          echo "SSH connection established"
          break
        fi
        echo "Attempt $i: SSH not ready yet, waiting 20 seconds..."
        sleep 20
        if [ $i -eq 6 ]; then
          echo "Failed to establish SSH connection after 6 attempts"
          echo "Terminating instance $INSTANCE_ID to avoid unnecessary charges"
          aws ec2 terminate-instances --region us-east-1 --instance-ids $INSTANCE_ID
          exit 1
        fi
      done
      
      # Create necessary directories and set permissions
      echo "Creating directories and setting permissions..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key ubuntu@$PUBLIC_IP "sudo mkdir -p /opt/cold-email/{app,scripts,k8s} && sudo chown -R ubuntu:ubuntu /opt/cold-email"
      
      # List local directory contents for debugging
      echo "Local directory contents:"
      ls -la
      
      # Copy files in parallel with proper error handling
      echo "Copying files..."
      copy_with_retries() {
        local src="$1"
        local dest="$2"
        local retries=3
        
        # Check if source exists
        if [ ! -e "$src" ]; then
          echo "Source $src does not exist!"
          ls -la $(dirname "$src")
          return 1
        fi
        
        for i in $(seq 1 $retries); do
          if scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key -r "$src" "ubuntu@$PUBLIC_IP:$dest"; then
            return 0
          fi
          echo "Attempt $i: Failed to copy $src, retrying in 5 seconds..."
          sleep 5
        done
        echo "Failed to copy $src after $retries attempts"
        return 1
      }

      # Copy each directory individually
      echo "Copying app directory..."
      copy_with_retries "app" "/opt/cold-email/" || exit 1
      
      echo "Copying scripts directory..."
      copy_with_retries "scripts" "/opt/cold-email/" || exit 1
      
      echo "Copying k8s directory..."
      copy_with_retries "k8s" "/opt/cold-email/" || exit 1
      
      # Verify files were copied
      echo "Verifying file copy..."
      if ! ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key ubuntu@$PUBLIC_IP "ls -la /opt/cold-email/{app,scripts,k8s}"; then
        echo "Failed to verify copied files"
        exit 1
      fi
      
      # Create and copy configuration files
      echo "Creating configuration files..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key ubuntu@$PUBLIC_IP "echo 'GROQ_API_KEY=$GROQ_API_KEY' | sudo tee /opt/cold-email/app/.env && sudo chown ubuntu:ubuntu /opt/cold-email/app/.env"
      
      # Make scripts executable
      echo "Making scripts executable..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key ubuntu@$PUBLIC_IP "chmod +x /opt/cold-email/scripts/*.sh || echo 'Failed to make scripts executable'"
      
      # Run setup script
      echo "Running setup script..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key ubuntu@$PUBLIC_IP "cd /opt/cold-email && sudo ./scripts/setup-k8s.sh"
      
      # Finalize deployment
      echo "Finalizing deployment..."
      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/ec2_key ubuntu@$PUBLIC_IP "cd /opt/cold-email && sudo ./scripts/deploy-k8s.sh"
      
      echo "Deployment completed successfully!"
  artifacts:
    reports:
      dotenv: lb_dns.env
    expire_in: 1 week
  when: on_success

monitor:
  stage: monitor
  image: python:3.9-slim
  script: |
    # Install required packages and setup in parallel
    apt-get update && apt-get install -y openssh-client python3-pip &
    pip install awscli &
    mkdir -p ~/.ssh && chmod 700 ~/.ssh &
    wait
    
    # Generate a new SSH key for this pipeline run
    echo "Generating new SSH key..."
    ssh-keygen -t rsa -b 2048 -f ~/.ssh/ec2_key -N ""
    chmod 600 ~/.ssh/ec2_key
    ssh-add ~/.ssh/ec2_key
    cat ~/.ssh/ec2_key.pub > ec2_key.pub
    
    # Set up SSH config
    echo -e "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config
    
    # Setup AWS credentials
    export AWS_DEFAULT_REGION=us-east-1
    export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
    export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
    
    # Debug AWS configuration
    echo "Verifying AWS configuration:"
    aws configure list
    echo "Testing AWS connection:"
    aws ec2 describe-regions --region us-east-1 --output text | head -1 || echo "AWS connection failed"
    
    # Get information about all EC2 instances
    echo "Listing all EC2 instances for troubleshooting:"
    aws ec2 describe-instances --region us-east-1 --query "Reservations[*].Instances[*].[InstanceId,State.Name,Tags[?Key=='Name'].Value|[0],PublicIpAddress]" --output text
    
    # Get instance IP with better error handling
    echo "Searching for EC2 instance..."
    INSTANCE_INFO=$(aws ec2 describe-instances \
      --region us-east-1 \
      --filters "Name=tag:Name,Values=cold-email-instance" "Name=instance-state-name,Values=running" \
      --query "Reservations[*].Instances[*].[InstanceId,PublicIpAddress]" \
      --output text)
    
    EC2_IP=$(echo "$INSTANCE_INFO" | awk '{print $2}')
    
    if [ -z "$EC2_IP" ]; then
      echo "Failed to get EC2 instance IP. Instance info:"
      echo "$INSTANCE_INFO"
      exit 1
    fi
    
    echo "Found EC2 instance with IP: $EC2_IP"
    
    # Define SSH command function with retries
    run_ssh_command() {
      local command="$1"
      for i in {1..3}; do
        echo "Attempt $i: Running command via SSH..."
        if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=5 -i ~/.ssh/ec2_key ${AWS_USER}@${EC2_IP} "$command"; then
          echo "Command executed successfully!"
          return 0
        fi
        echo "Command failed. Waiting 10 seconds before retry..."
        sleep 10
      done
      echo "Failed to execute command after 3 attempts."
      return 1
    }
    
    # Run health checks in parallel
    run_ssh_command "kubectl get pods -n cold-email" &
    run_ssh_command "kubectl get svc -n cold-email" &
    wait
    
    # Check application health
    sleep 15
    curl -s -f -m 5 "http://${EC2_IP}/_stcore/health" || echo "Health check failed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  artifacts:
    reports:
      dotenv: lb_dns.env
    expire_in: 1 week